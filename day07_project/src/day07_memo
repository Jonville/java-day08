 상속 ( 부모클래스 + 자식클래스 )
 
 1. 자바는 다중상속을 지원하지 않음.
 2. 상속 횟수 무제한
 3. 상속의 최상위 클래스는 java.lang.Object 클래스
 
 서브 클래스의 생성자를 생성할경우, 슈퍼 클래스의 생성자가 먼저 실행된다!!
 호출 자체는 서브 클래스가 먼저인데, 실행은 슈퍼 클래스가 먼저 실행됨.
 
 		==> 결론은 생성자 호출 후! 생성자 실행 ! 순서로 진행된다.
 					실행이 나중에 된다는게 핵심이다.
 					
 
 따로 지정하지않으면 기본 생성자를 가리킨다.
 그래서 매개변수가있는 생성자를 생성할때, 부모클래스에서 기본 생성자도 같이 생성해주는게 좋다.
 
 자식 클래스에서 매개변수가 있더라도, 무조건 부모의 기본생성자를 호출함!! (중요)
 
 
 --- 부모의 매개변수있는 생성자를 사용하고 싶을때 ! super()    ----
 
 super() 는 반드시 맨 앞줄에 와야함.
 
 super(매개변수)	<-- 부모클래스와 맞는 매개변수를 입력해주면됨.	매개변수 값을 잘 맞춰줘야한다. 1개인지 2개인지 3개인지...
 		==> 자식클래스 생성자에서 부모클래스에있는 생성자를 쓰려고 만든 메소드.
 		
 		
 -----업캐스팅(upcasting) ------
 
 업캐스팅이란?
 		서브 클래스 객체를 슈퍼 클래스 타입으로 타입 변환.
 		int 형이 double 형 에 속할수있는것처럼 형 변환이 가능하다!  
 		
 		업캐스팅 된 레퍼런스는.. 객체 내에 슈퍼 클래스의 멤버만 접근 가능.
 		
 		class Person
 		class Student extends Person
 		
 		Student s = new Student();
 		Person p = s ;				<< == 이렇게 선언하는데 Person 에있는 멤버만 접근 가능해진다~
 		
 		Student 에만 선언된 멤버 변수는 사용이 불가능해진다.
 		
 다운캐스팅이란?			업개스팅이랑 반대 개념
 		슈퍼 클래스 객체를 서브 클래스 타입으로 변환.
 		
 		Student s = (Student)p;		// 대괄호로 형변환 시켜준다!
 						--> 고로 p 는 Person 뿐만아닌 Student 클래스에 접근이 가능해진다. (Student 형태로 강제 형변환 시켰기 때문에)
 						
 						
 instanceof 연산자
 		업캐스팅된 레퍼런스로 객체의 타입 판단이 어려움.
 		그래서 instanceof 연산자를 사용
 	    ==================================
 		void print(Student st){			
 				...
 		}
 		
 		void print(Re re){		
 				...
 		}
 		
 		void print(Pro pro){			
 				...
 		}
 		=============================== 위에 코드가 많아지기때문에  밑에있는것 처럼 한번에 쓸수있다. ========
 		void print(Person person){			// Person 형의 person 을 쓴다는 의미
 				...
 		}
 		
 	사용법
 		if(kim instanceof Student)		<-- Student에 kim 이 있냐고 물어보는 것	
 		
 	--------------------------------------------------
 	
 	
 메소드 오버라이딩 (Method Overriding)
 	- 상속 클래스에서의 재정의
 		슈퍼 클래스 메소드의 이름, 매겨변수 타입 및 개수, 리턴 타입 등 모든것이 동일해야 함.
 	- 동적 바인딩
		자식 클래스에있는것을 호출함. 		
		부모클래스로 가긴하는데, 컴파일할때 오버라이딩 이 된것을 찾아서, 자식클래스의 오버라이딩 된 클래스를 실행한다. ( 이걸 동적 바인딩 이라고함 )
		
	============================================================================		
	
연결 리스트란
 	int arr = {1,2,5,4,6}
 	[1, 2address] , [2, 5address] , [5, 4address] , [4, 6address] , [6]
 	
 	이렇게 연결 시켜줘서 선언해준다. 그러고 2와 5 사이에 3을 넣어주고싶으면
 	[1, 2address] , *[2, 3address] , [5, 4address] , [4, 6address] , [6]
 	*[3, 5address]
 	
 	이 두개만 변경해주면 된다. ( 배열의 단점을 보완해줬음 )
 
 Stack => LIFO
 	Last In First Out
 
 Que => FIFO
 	First In First Out	
	============================================================================
	
오버라이딩과 super 키워드
	- super 는 슈퍼 클래스의 멤버를 접근할때 사용되는 레퍼런스
	- 서브클래스에서만 사용	
	
	- 정적 바인딩.
	
	그냥 super  =  슈퍼 클래스를 호출할때 쓴다 라고 생각하면된다.	
	
		
		
	===========================================================================
	
추상 메소드(abstract method)

	선언되어 있으나 구현되어 있지 않은 메소드, abstract 로 선언
	
	추상 메소드는 서브 클래스에서 오버라이딩하여 구현해야함.

	======================================================================

추상 클래스(abstract class)

	추상 메소드를 하나라도 가진 클래스
		(반드시 abstract 라고 선언해야함)
	추상 메소드를 안 가진 추상 클래스	
	
!!!! 추상 클래스는 객체를 생성할수 없다 !!!!
		==> 이친구는 단순히 상속 받기 위함용임.;
	추상 메소드를 구현하지 않으면 추상 클래스가 되어버림.
	그래서 추상 메소드에도 꼭 abstract를 선언해야함.
	
	추상클래스의 용도
		- 설계와 구현 분리
			슈퍼클래스에는 개념정의, 각 서브 클래스에서 구체적 행위 구현	
		- 계층적 상속관계를 갖기위해
		
	======================================================================
	
인터페이스 (Interface)
		: 설계도면 이라 생각
	모든 메소드가 추상 메소드인 클래스!!!!! (아주 중요)			{} 이거 안쓰임 그냥 메소드() 하고 끝.
	
	인터페이스 안에서 메소드를 선언하면 알아서 abstract 가 선언이됨
			----> 그래서 따로 선언 안해줘도됩니다.
			ex ) public abstract nnn(); -- > public nnn();
			
	객체 생성 불가능하지만,
	인터페이스 타입의 레퍼런스 변수은 선언 가능
	
	!!구현할 클래스내에서 구체화 시켜줘야함!! -> 왜냐면 객체를 따로 생성하지않기때문에 누군가가 받아줘서 써줘야한다.
		implements ....
		하고 Overriding 을 시켜줘야함.
		
	인터페이스는 또 다른 인터페이스를 상속 받을수있다. ( 잘 안쓰임 )
	
	인터페이스 안에서 default 인터페이스 메소드는 추상 메소드가 아님.
	
인터페이스 쓰는 목적
	: 클래스의 규격 선언, 클래스의 다형성을 실현, 협약 및 통일성
		
	===========================================================================
	
메소드를 편리하게 쓰는방법 (리턴타입에 신경안쓰고 )
	 Object 를 매개변수로 써버리면 다 가능해져 버린다. ex ) (Object obj) { ... }
	 	하지만 불필요한 값들도 다 들어가서 조심해서 쓰는게 좋다.
	 		평소에 쓰는 것은 지양해라.
  

	
	
 