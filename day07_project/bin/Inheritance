 상속 ( 부모클래스 + 자식클래스 )
 
 1. 자바는 다중상속을 지원하지 않음.
 2. 상속 횟수 무제한
 3. 상속의 최상위 클래스는 java.lang.Object 클래스
 
 서브 클래스의 생성자를 생성할경우, 슈퍼 클래스의 생성자가 먼저 실행된다!!
 호출 자체는 서브 클래스가 먼저인데, 실행은 슈퍼 클래스가 먼저 실행됨.
 
 		==> 결론은 생성자 호출 후! 생성자 실행 ! 순서로 진행된다.
 					실행이 나중에 된다는게 핵심이다.
 					
 
 따로 지정하지않으면 기본 생성자를 가리킨다.
 그래서 매개변수가있는 생성자를 생성할때, 부모클래스에서 기본 생성자도 같이 생성해주는게 좋다.
 
 자식 클래스에서 매개변수가 있더라도, 무조건 부모의 기본생성자를 호출함!! (중요)
 
 
 --- 부모의 매개변수있는 생성자를 사용하고 싶을때 ! super()    ----
 
 super() 는 반드시 맨 앞줄에 와야함.
 
 super(매개변수)	<-- 부모클래스와 맞는 매개변수를 입력해주면됨.	매개변수 값을 잘 맞춰줘야한다. 1개인지 2개인지 3개인지...
 		==> 자식클래스 생성자에서 부모클래스에있는 생성자를 쓰려고 만든 메소드.
 		
 		
 -----업캐스팅(upcasting) ------
 
 업캐스팅이란?
 		서브 클래스 객체를 슈퍼 클래스 타입으로 타입 변환.
 		int 형이 double 형 에 속할수있는것처럼 형 변환이 가능하다!  
 		
 		업캐스팅 된 레퍼런스는.. 객체 내에 슈퍼 클래스의 멤버만 접근 가능.
 		
 		class Person
 		class Student extends Person
 		
 		Student s = new Student();
 		Person p = s ;				<< == 이렇게 선언하는데 Person 에있는 멤버만 접근 가능해진다~
 		
 		Student 에만 선언된 멤버 변수는 사용이 불가능해진다.
 		
 다운캐스팅이란?			업개스팅이랑 반대 개념
 		슈퍼 클래스 객체를 서브 클래스 타입으로 변환.
 		
 		Student s = (Student)p;		// 대괄호로 형변환 시켜준다!
 						--> 고로 p 는 Person 뿐만아닌 Student 클래스에 접근이 가능해진다. (Student 형태로 강제 형변환 시켰기 때문에)
 						
 						
 instanceof 연산자
 		업캐스팅된 레퍼런스로 객체의 타입 판단이 어려움.
 		그래서 instanceof 연산자를 사용
 	    ==================================
 		void print(Student st){			
 				...
 		}
 		
 		void print(Re re){		
 				...
 		}
 		
 		void print(Pro pro){			
 				...
 		}
 		=============================== 위에 코드가 많아지기때문에  밑에있는것 처럼 한번에 쓸수있다. ========
 		void print(Person person){			// Person 형의 person 을 쓴다는 의미
 				...
 		}
 		
 	사용법
 		if(kim instanceof Student)		<-- Student에 kim 이 있냐고 물어보는 것	
 		
 	--------------------------------------------------
 	
 	
 메소드 오버라이딩 (Method Overriding)
 	- 상속 클래스에서의 재정의
 		슈퍼 클래스 메소드의 이름, 매겨변수 타입 및 개수, 리턴 타입 등 모든것이 동일해야 함.
 	- 동적 바인딩
		자식 클래스에있는것을 호출함. 		
		부모클래스로 가긴하는데, 컴파일할때 오버라이딩 이 된것을 찾아서, 자식클래스의 오버라이딩 된 클래스를 실행한다. ( 이걸 동적 바인딩 이라고함 )